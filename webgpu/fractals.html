<!DOCTYPE html>
<html>

<head>
    <title>WebGL Fractal</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>
    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('Your browser does not support WebGL');
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0, 1);
            }
        `;

        const fragmentShaderSource = `
            precision highp float;

            uniform vec2 u_resolution;
            uniform vec2 u_pan;
            uniform float u_zoom;
            const int max_iterations = 512;
            const int aa_root = 2;
            const int aa_max = aa_root * aa_root + 1;
            const float aa_dx = float(aa_max) / float(aa_root);
            const float aa_dy = 1. / float(aa_max);

            void main() {
                vec3 color = vec3(0.0);
                
                for (int aa = 0; aa < aa_max; aa++) {
                    vec2 offset = vec2(
                        float(aa) * aa_dx - float(int(float(aa) * aa_dx)),
                        float(aa) * aa_dy
                    );
                    vec2 c = ((gl_FragCoord.xy + offset) - u_resolution * 0.5) / (u_zoom * u_resolution.y) + u_pan;

                    vec2 z = vec2(0.0, 0.0);
                    float mu = float(max_iterations);
                    for (int i = 0; i < max_iterations; i++) {
                        z = vec2(
                            z.x * z.x - z.y * z.y + c.x,
                            2.5 * z.x * z.y + c.y
                        );
                        if (dot(z, z) > 4.0) {
                            mu = float(i);
                            break;
                        }
                    }

                    if (mu < float(max_iterations)) {
                        mu -= log2(log2(dot(z, z))) + 4.0;
                    }
                    float t = mu / float(max_iterations);

                    color += vec3(
                        clamp(t * 3. - 2., 0.0, 1.0),
                        clamp(t * 3. - 1., 0.0, 1.0),
                        clamp(t * 3. - 0., 0.0, 1.0)
                    );
                }

                color /= float(aa_max);
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) {
                return shader;
            }

            alert(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            const success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (success) {
                return program;
            }

            console.error(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        const positions = [
            -1, -1,
            1, -1,
            -1, 1,
            -1, 1,
            1, -1,
            1, 1,
        ];

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');
        const panUniformLocation = gl.getUniformLocation(program, 'u_pan');
        const zoomUniformLocation = gl.getUniformLocation(program, 'u_zoom');
        const iterationsUniformLocation = gl.getUniformLocation(program, 'u_iterations');

        gl.useProgram(program);

        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(
            positionAttributeLocation, // Attribute location
            2, // Number of elements per attribute
            gl.FLOAT, // Type of elements
            false, // Normalized?
            0, // Stride
            0 // Offset
        );

        let panX = 0.0;
        let panY = 0.0;
        let zoom = 1.0;
        let iterations = 100;

        // Parse URL fragment
        function parseURLFragment() {
            const hash = window.location.hash.substring(1);
            const params = new URLSearchParams(hash);
            panX = parseFloat(params.get('x')) || 0.0;
            panY = parseFloat(params.get('y')) || 0.0;
            zoom = parseFloat(params.get('zoom')) || 1.0;
        }

        // Update URL fragment
        function updateURLFragment() {
            const params = new URLSearchParams();
            params.set('x', panX.toFixed(6));
            params.set('y', panY.toFixed(6));
            params.set('zoom', zoom.toFixed(6));
            window.history.replaceState(null, null, `#${params.toString()}`);
        }

        // Parse URL fragment on load
        parseURLFragment();

        function drawScene() {
            resizeCanvas();
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
            gl.uniform2f(panUniformLocation, panX, panY);
            gl.uniform1f(zoomUniformLocation, zoom);
            gl.uniform1i(iterationsUniformLocation, iterations);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Update URL fragment after drawing
            updateURLFragment();
        }

        drawScene();

        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;

                panX -= dx / (zoom * canvas.height);
                panY += dy / (zoom * canvas.height);

                lastX = e.clientX;
                lastY = e.clientY;

                drawScene();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY * -0.001;
            const zoomFactor = Math.exp(delta);

            zoom *= zoomFactor;

            // Adjust pan to zoom towards mouse position
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const cx = (x / canvas.width - 0.5) * 2.0;
            const cy = (y / canvas.height - 0.5) * -2.0;

            panX += cx * (1 - 1 / zoomFactor) / zoom;
            panY += cy * (1 - 1 / zoomFactor) / zoom;

            drawScene();
        });

        let lastTouchDistance = 0;
        let lastTouchX = 0;
        let lastTouchY = 0;

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length == 1) {
                isDragging = true;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            } else if (e.touches.length == 2) {
                isDragging = false;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                lastTouchX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                lastTouchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length == 1 && isDragging) {
                const dx = e.touches[0].clientX - lastX;
                const dy = e.touches[0].clientY - lastY;

                panX -= dx / (zoom * canvas.height);
                panY += dy / (zoom * canvas.height);

                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;

                drawScene();
            } else if (e.touches.length == 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const touchDistance = Math.sqrt(dx * dx + dy * dy);

                const zoomFactor = touchDistance / lastTouchDistance;

                zoom *= zoomFactor;

                // Adjust pan to zoom towards touch center
                const rect = canvas.getBoundingClientRect();
                const x = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
                const y = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;

                const cx = (x / canvas.width - 0.5) * 2.0;
                const cy = (y / canvas.height - 0.5) * -2.0;

                panX += cx * (1 - 1 / zoomFactor) / zoom;
                panY += cy * (1 - 1 / zoomFactor) / zoom;

                lastTouchDistance = touchDistance;
                lastTouchX = x;
                lastTouchY = y;

                drawScene();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                lastTouchDistance = 0;
            }
            if (e.touches.length == 0) {
                isDragging = false;
            }
        });

    </script>
</body>

</html>