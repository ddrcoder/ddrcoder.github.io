<!DOCTYPE html>
<html>

<head>
    <title>WebGPU Fractal</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #toolbar {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #reset-button {
            margin-right: auto;
            background-color: #f0f0f0;
            border: none;
            padding: 5px 10px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>
    <div id="toolbar">
        <button id="reset-button" title="Reset view">â†º</button>
        <span>Iterations: </span><span id="iter-display">100</span>
    </div>
    <script type="module">
        const canvas = document.querySelector('canvas');
        
        // Initialize WebGPU
        if (!navigator.gpu) {
            throw new Error('WebGPU not supported');
        }

        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');

        const format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
            device,
            format,
            alphaMode: 'premultiplied',
        });

        // Create uniform buffer
        const uniformBuffer = device.createBuffer({
            size: 32, // 4 floats for pan(x,y), zoom, max_iter, t
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        // Create shader
        const shaderModule = device.createShaderModule({
            label: "Fractal shader",
            code: `
                struct Uniforms {
                    pan: vec2f,
                    zoom: f32,
                    max_iter: f32,
                    t: f32,
                };
                @group(0) @binding(0) var<uniform> uniforms: Uniforms;

                struct VertexOutput {
                    @builtin(position) position: vec4f,
                    @location(0) uv: vec2f,
                };

                @vertex
                fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
                    let pos = array(
                        vec2f(-1.0, -1.0),
                        vec2f(1.0, -1.0),
                        vec2f(-1.0, 1.0),
                        vec2f(1.0, -1.0),
                        vec2f(1.0, 1.0),
                        vec2f(-1.0, 1.0),
                    );

                    var output: VertexOutput;
                    output.position = vec4f(pos[vertexIndex], 0.0, 1.0);
                    output.uv = pos[vertexIndex];
                    return output;
                }

                // Your existing F64 and C64 implementations here
                alias F64 = vec2f;
                alias C64 = vec4f;

                fn f64add(a: F64, b: F64) -> F64 {
                    let xh = a.x;
                    let xl = a.y;
                    let yh = b.x;
                    let yl = b.y;

                    let sh = xh + yh;
                    let sl = xl + yl;
                    let c = sl + (xh - (sh - yh)) + (yh - (sh - xh));
                    let zh = sh + c;
                    let zl = c - (zh - sh);

                    return F64(zh, zl);
                }

                fn f64mul(x: F64, y: F64) -> F64 {
                    let xh = x.x;
                    let xl = x.y;
                    let yh = y.x;
                    let yl = y.y;

                    let p = xh * yh;
                    let q = xh * yl + xl * yh;
                    let zh = p + q;
                    let zl = q - (zh - p);

                    return F64(zh, zl);
                }

                fn c64add(a: C64, b: C64) -> C64 {
                    C64(
                        f64add(a.xy, b.xy),
                        f64add(a.zw, b.zw)
                    )
                }

                fn c64mul(a: C64, b: C64) -> C64 {
                    return C64(
                        f64add(f64mul(a.xy, b.xy), -f64mul(a.zw, b.zw)),
                        f64add(f64mul(a.xy, b.zw), f64mul(a.zw, b.xy))
                    );
                }

                fn f64mag2(f: F64) -> f32 {
                    return f.x * f.x + 2.0 * f.x * f.y + f.y * f.y;
                }

                fn c64mag2(c: C64) -> f32 {
                    return f64mag2(c.xy) + f64mag2(c.zw);
                }

                fn iterate(z: C64, c: C64) -> f32 {
                    var z_current = z;
                    for (var i: i32 = 0; i < 2048; i++) {
                        if (f32(i) >= uniforms.max_iter) { break; }
                        z_current = c64add(c64mul(z_current, z_current), c);
                        let mag2 = c64mag2(z_current);
                        if (mag2 > 64.0) {
                            return (f32(i) - log2(log2(mag2)) + 4.0) / uniforms.max_iter;
                        }
                    }
                    return 1.0;
                }

                @fragment
                fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
                    let aspect = 1.0;
                    let uv = input.uv * vec2f(aspect, 1.0) * uniforms.zoom + uniforms.pan;
                    
                    let c = C64(F64(uv.x, 0.0), F64(uv.y, 0.0));
                    let z = C64(F64(0.0, 0.0), F64(0.0, 0.0));
                    
                    let t = iterate(z, c);
                    
                    // Color mapping
                    let color = vec3f(
                        0.5 + 0.5 * cos(3.0 + t * 6.28 + vec3f(0.0, 0.6, 1.0))
                    );
                    
                    return vec4f(color, 1.0);
                }
            `
        });

        // Create pipeline
        const pipeline = device.createRenderPipeline({
            layout: 'auto',
            vertex: {
                module: shaderModule,
                entryPoint: 'vertexMain',
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fragmentMain',
                targets: [{
                    format,
                }],
            },
        });

        // Create bind group
        const bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [{
                binding: 0,
                resource: {
                    buffer: uniformBuffer,
                },
            }],
        });

        // State variables
        let pan = [0, 0];
        let zoom = 1;
        let maxIter = 100;
        let t = 0;

        function updateUniforms() {
            device.queue.writeBuffer(
                uniformBuffer,
                0,
                new Float32Array([...pan, zoom, maxIter, t])
            );
        }

        function draw() {
            const commandEncoder = device.createCommandEncoder();
            const textureView = context.getCurrentTexture().createView();

            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: textureView,
                    clearValue: { r: 0, g: 0, b: 0, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }],
            });

            renderPass.setPipeline(pipeline);
            renderPass.setBindGroup(0, bindGroup);
            renderPass.draw(6);
            renderPass.end();

            device.queue.submit([commandEncoder.finish()]);
        }

        // Event handlers
        function resetView() {
            pan = [0, 0];
            zoom = 1;
            maxIter = 100;
            t = 0;
            updateUniforms();
            draw();
        }

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 1.1 : 0.9;
            zoom *= factor;
            
            // Zoom toward mouse position
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width * 2 - 1;
            const y = (e.clientY - rect.top) / rect.height * 2 - 1;
            
            pan[0] += x * (1 - factor) / zoom;
            pan[1] += y * (1 - factor) / zoom;
            
            updateUniforms();
            draw();
        });

        let isDragging = false;
        let lastX, lastY;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            lastX = e.clientX;
            lastY = e.clientY;

            pan[0] -= dx * 2 / canvas.width / zoom;
            pan[1] -= dy * 2 / canvas.height / zoom;
            
            updateUniforms();
            draw();
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        document.getElementById('reset-button').addEventListener('click', resetView);

        // Initial setup
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        updateUniforms();
        draw();
    </script>
</body>
